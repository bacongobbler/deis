#!/bin/bash
#
# This script is designed to be run inside the container
#

# fail hard and fast even on pipelines
set -eo pipefail
set -x

# set debug based on envvar
[[ $DEBUG ]] && set -x

# configure redis
export REDIS_HOST=${REDIS_HOST:-localhost}
export REDIS_URL=${REDIS_URL:-localhost:6379}
export REDIS_PATH=${REDIS_PATH:-/deis/controller}

export DATABASE_HOST=${DATABASE_HOST:-localhost}

function redis_set_default {
	set +e
	ERROR="$(redis-cli -h $REDIS_HOST set $REDIS_PATH/$1 $2 2>&1 >/dev/null)"
	if [[ $? -ne 0 ]]; then
		echo "redis_set_default: a redis error occurred ($ERROR)"
		echo "aborting..."
		exit 1
	fi
	set -e
}

redis_set_default protocol ${DEIS_PROTOCOL:-http}
redis_set_default secretKey ${DEIS_SECRET_KEY:-`openssl rand -base64 64 | tr -d '\n'`}
redis_set_default builderKey ${DEIS_BUILDER_KEY:-`openssl rand -base64 64 | tr -d '\n'`}
redis_set_default registrationMode "enabled"
redis_set_default webEnabled 0
redis_set_default unitHostname default

# wait for confd to run once and install initial templates
until confd -backend redis -onetime -node $REDIS_URL --confdir /app --log-level error; do
	echo "controller: waiting for confd to write initial templates..."
	sleep $(($ETCD_TTL/2))  # sleep for half the TTL
done

cd /app

mkdir -p /data/logs
chmod 777 /data/logs

# run an idempotent database migration
sudo -E -u deis ./manage.py syncdb --migrate --noinput

# smart shutdown on SIGTERM (SIGINT is handled by gunicorn)
function on_exit() {
	GUNICORN_PID=$(cat /tmp/gunicorn.pid)
	kill -TERM $GUNICORN_PID 2>/dev/null
	wait $GUNICORN_PID 2>/dev/null
	exit 0
}
trap on_exit TERM

# spawn confd in the background to update services based on redis changes
confd -backend redis -node $REDIS_URL --confdir /app --log-level error --interval 5 &
CONFD_PID=$!


echo deis-controller running...

# spawn the api server
sudo -E -u deis gunicorn -c deis/gconf.py deis.wsgi
